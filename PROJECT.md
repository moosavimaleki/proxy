## 1. تحلیل مسئله

| نیاز کسب‌وکار                                                                      | چالش فنی                                                                                                                                 | راهکار پیشنهادی                                                                                                                                                    |
| ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ‌در اختیار گذاشتن یک Proxy واحد برای کاربر نهایی که همیشه **در دسترس و سریع** باشد | ❶ سالم نگه داشتن یک «استخر» بزرگ از پراکسی‌های ناهمگون (VMess / VLess / Shadowsocks …).<br>❷ انتخاب بهترین مسیر برای هر درخواست در لحظه. | دو پایپ‌لاین مستقل: <br>**A. پایش (Probe)** — پراکندگی و ارزیابی بلادرنگ کانفیگ‌ها <br>**B. دروازه (Gateway)** — سرو یس‌دهی کاربر با Load-Balancing روی استخر سالم |
| اضافه / حذف لحظه‌ای کانفیگ‌ها                                                      | API یا DB بلادرنگ + Hot-Reload                                                                                                           | استفاده از API داخل Clash                                                                                                                                          |
| مقیاس‌پذیری (هزاران پراکسی)                                                        | سربار RAM/CPU، مدیریت فایل‌های موقتی                                                                                                     | یک Clash «Probe» کم‌مصرف که فقط delay می‌گیرد، یک Clash «Gateway» با گروه load-balance                                                                             |
| انکپسوله‌ کردن پشت یک آدرس ثابت                                                    | یک Mixed-Port (HTTP+SOCKS)                                                                                                               | Clash «Gateway» روی پورت ثابت (مثلاً 8000)                                                                                                                         |
| نگه‌داری دیتا                                                                      | سادگی + تراکنش اتمیک                                                                                                                     | SQLite برای PoC → قابل ارتقا به PostgreSQL                                                                                                                         |

---

## 2. انتزاع‌ لایه‌ها و سرویس‌ها

```
                   ┌────────────────────────────┐
                   │     Client Applications    │
                   │ (Browser, Curl, Telegram…) │
                   └─────────────┬──────────────┘
                                 │  Mixed-Port 8000
                                 ▼
                      ┌───────────────────────┐
                      │   Clash GATEWAY       │
                      │  (mode: load-balance) │
                      │  Group = "POOL"       │
                      └─────────────┬─────────┘
                                    │  API / Hot-Reload
                 ┌──────────────────┴──────────────────┐
                 ▼                                     ▼
     ┌──────────────────────┐              ┌──────────────────────┐
     │  Persistent Storage  │              │   Clash PROBE        │
     │  SQLite table:       │◄────update───┤  (mode: global)      │
     │  proxies(id, uri,    │              │  tests delay/health) │
     │  healthy, last_ok)   │              └──────────────────────┘
     └──────────────────────┘
```

### کامپوننت‌ها و Interfaceها

| لایه              | نقش                  | ورودی/خروجی                           | فن‌آوری                                |
| ----------------- | -------------------- | ------------------------------------- | -------------------------------------- |
| **Fetcher**       | اسکریپت جمع‌آوری URI | URL ریپازیتوری‌ها → `proxies.raw`     | Python + GitHub API                    |
| **Probe Clash**   | تست مداوم            | خواندن `proxies.raw`, نوشتن `healthy` | Clash core + REST (`/proxies/*/delay`) |
| **Database**      | مرجع واحد            | SQL (insert/update)                   | SQLite → SQLAlchemy                    |
| **Gateway Clash** | سرویس‌دهی            | YAML تولیدشده از لیست سالم‌ها         | Clash core + `url-test`/`load-balance` |
| **Orchestrator**  | هماهنگ‌کننده         | تغییر در DB ↔ Hot-Reload Gateway      | Python (async)                         |

---

## 3. مراحل توسعه (بر اساس اولویت کسب‌وکار)

| فاز                          | شرح دقیق تسک                                                                                                                                                                                                       | خروجی قابل تحویل                           |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------ |
| **۰. آماده‌سازی**            | 0-1 نصب Clash Premium/Meta.<br>0-2 راه‌اندازی repo Git.                                                                                                                                                            | باینری Clash در PATH.                      |
| **۱. پایگاه داده و مدل**     | 1-1 تعریف اسکیمای SQLite (جدول `proxies`).<br>1-2 لایه DAL با SQLAlchemy.                                                                                                                                          | `models.py`, اسکریپت `init_db.py`          |
| **۲. Fetcher (جمع‌آوری)**    | 2-1 نوشتن crawler ساده که URIهای github/telegram را استخراج کند.<br>2-2 درج/به‌روزرسانی رکوردها در جدول (وضعیت `healthy`=NULL).                                                                                    | `fetcher.py` + cron systemd                |
| **۳. Probe Service**         | 3-1 تبدیل URI→فرمت Clash (Python).<br>3-2 تولید YAML، بوت Clash Probe (mixed-port غیرقابل اکسپوز).<br>3-3 حلقه‌ی `delay` موازی؛ آپدیت ستون `healthy` و `last_ok`.<br>3-4 مارک‌کردن رکوردهای dead بعد از N بار خطا. | `probe_service.py`; لاگ سلامت روزانه       |
| **۴. Gateway Service (MVP)** | 4-1 خواندن سالم‌ها؛ تولید YAML برای Clash Gateway (Mixed-Port 8000).<br>4-2 بوت اولیه؛ گروه `load-balance`.<br>4-3 Watcher: هر X ثانیه diff می‌گیرد؛ در صورت تغییر `PATCH /configs` یا ری‌استارت.                  | `gateway_service.py` آمادهٔ docker-compose |
| **۵. Monitoring & Metrics**  | 5-1 جمع‌آوری متریک delay میانگین هر پراکسی (Prometheus exporter یا log).<br>5-2 هشدار روی افت شدید سالم‌ها.                                                                                                        | `metrics.py`,   Grafana dashboard          |
| **۶. Security & Hardening**  | 6-1 محدود‌کردن دسترسی API Clash به 127.0.0.1 با token.<br>6-2 firewall برای پرت‌های داخلی.<br>6-3 Logging rotation.                                                                                                | مستند امن‌سازی + اسکریپت iptables          |
| **۷. استقرار (Prod)**        | 7-1 Dockerfile برای هر سرویس (Fetcher, Probe, Gateway).<br>7-2 docker-compose یا systemd units.<br>7-3 مستند نصب/راه‌اندازی روی VPS.                                                                               | `docker-compose.yml`, README               |
| **۸. بهبودها**               | 8-1 الگوریتم هوشمند انتخاب (latency+حاشیه خطا).<br>8-2 پشتیبانی Reality, Hysteria2.<br>8-3 API HTTP برای افزودن/حذف URI در لحظه.                                                                                   | نسخه 2.0                                   |

---

## 4. تسک‌های عملیاتی و تحویل

| #         | تسک                                 | مسئول   | مدت (روز)        | خروجی / Acceptance                              |
| --------- | ----------------------------------- | ------- | ---------------- | ----------------------------------------------- |
| 1         | طراحی DB + DAL                      | Backend | 0.5              | تست `sqlite:///test.db` پاس شود                 |
| 2         | اسکریپت Fetch اولیه (GitHub)        | Backend | 1                | `python fetcher.py` ≥100 URI جمع کند            |
| 3         | مبدل URI→ClashProxy                 | Backend | 1                | تست واحد 90٪ موارد موفق                         |
| 4         | YAML-ساز + بوت Clash Probe          | DevOps  | 1                | delay API قابل دسترس روی 9090                   |
| 5         | حلقهٔ Probe و آپدیت DB              | Backend | 1                | حداقل 80٪ URI مرده mark شود                     |
| 6         | YAML-ساز Gateway + ری‌استارت خودکار | Backend | 1                | curl به 8000 پاسخ OK دهد                        |
| 7         | Dockerfile + Compose                | DevOps  | 1                | `docker compose up` همه سرویس‌ها را بالا بیاورد |
| 8         | مستند امنیت + فایروال               | DevOps  | 0.5              | اسکریپت نصب اجرا شود                            |
| 9         | متریک Prometheus                    | DevOps  | 1                | endpoint `/metrics` آماده                       |
| **مجموع** |                                     |         | **\~8 روز کاری** | MVP آماده بهره‌برداری                           |

---

### نکات اجرای سریع

1. **Clash نسخه Premium/Meta** از `url-test` برای انتخاب سریع‌ترین پراکسی استفاده می‌کند؛ دیگر نیازی نیست در کد خودتان انتخاب کنید.
2. برای Hot-Reload بدون ری‌استارت می‌توانید از `PUT /configs` (Clash Premium 2023+) استفاده کنید؛ اما در PoC ری‌استارت ساده‌تر است.
3. دیتابیس را روی دیسک RAM (tmpfs) هم می‌توانید بیندازید تا write-load کمتر شود، سپس هر ساعت snapshot بگیرید.
4. Probe و Gateway روی یک ماشین هم جواب می‌دهد؛ ولی برای مقیاس بالاتر جدا کنید تا Probe ترافیک را مختل نکند.
5. اگر TLS اجباری است، Gateway را پشت Nginx Reverse Proxy بیاورید و پرت داخلی Clash را فقط لوکال نگه دارید.



# هدف ازاین پروژه چیست؟

هدف من ساخت یک پروکسی هست در پشت خودش هزاران پروکسی فعال دارد و بین اونها درخواست ها رو میچرخونه

این هزاران پروکسی ای که در آن پشت فعال هستن مدام پایش میشن و بررسی میشن و فقط سالم ها آنجا باقی می مانند

در نتیجه من یه سرویس بالا میارم که دیتابیس داره و داده هارو ذخیره وی کنه و همه چیز رو پشت یک پروکسی ساده انکپسولیت کرده

درست مثل multi tor

از تو میخوام دستور العمل تولید چنین نرم افزاری رو مرحله به مرحله بنویسی

ابتدا باید نرم افزار رو تحلیل کنی و سپس انتزاع های لازم را طراحی کنی
به نظر من ما به دو clash نیاز داریم
یک clash برای تست مداوم کانفیگ ها برای پر کردن استخر کانفیگ هاس سالم

یک clash هم کل کانفیگ های استخر رو بالا میاره برای استفاده پروداکشن  اما بصورت haproxy 